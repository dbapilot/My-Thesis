\section{Methodology}\vspace{.4cm}

 \subsection{ How materialized views work on MSSQL:} Not every database supports materialized views, and those that do each handle them a little differently, especially when it comes to the approach to view maintenance \cite{hattemer-2020}. Microsoft SQL server supports materialized views. Still, they are called "indexed views" because a materialized view may be indexed in multiple ways, and a materialization step is a matter of creating an index on a regular view. A view is materialized by creating a unique clustered index on an existing view. Uniqueness implies that the view output must contain a unique key. An indexable view must be defined by a single-level SQL statement containing selections, inner joins, and optional group-by \cite{goldstein-2001}.\vspace{0.8cm}

 To create materialized views on mssql we have to create a  regular view and then a clustered index on the view:
 \begin{itemize}
     \item {Create a regular view with schema binding:}\vspace{0.4cm}
     
\input{SQL/MV_on_mssql}
The queries specify the schema and name of the view. Schema binding options bind the view to the schema of the underlying tables. This prevents changes to the base tables from affecting the view's definition.
      \item {Create a unique clustered index on the view:}\vspace{0.4cm}
      
\input{SQL/Clustered_view} \vspace{0.4cm}

This statement materializes the view and stores the result in a clustered index.
\end{itemize}



 
\subsection{Deciding when to create a materialized or a regular view}\vspace{0.4cm}

There are some key factors to consider when deciding to create a materialized view or a regular view:\vspace{0.4cm}

\input{Table/Regular_vs_MV_View}
\vspace{1cm}

 \subsection{Cost Model}
Materialized views are a great optimization method. However, there is a cost associated with the jobs that maintain them. This section will discuss the cost model of Materialized view.\vspace{.4cm}
 \begin{enumerate}[label=\alph*)]
    \item \textbf{Computing cost :} Computing cost mostly depends on the workload and data size. Query processing and data transferring, there are refresh mechanisms to stay accurate. All these procedures are costly. Both the initial creation and subsequent refreshes of materialized views consume compute resources.
    \item \textbf{Maintenance cost:} These costs are associated with keeping Materialized views up-to-date and on service as base data changes. Every refresh or recalculation uses compute resources. Regular tuning, indexing, and monitoring to ensure the view optimally benefits query performance. The frequency of updates to base tables and the complexity of the materialized view impact these costs. 
    \item \textbf{Storage cost}: Materialized views require additional disk space, particularly for large databases. The gain in query performance should offset the storage cost of MV. Disabled views still incur storage costs, even if they're not maintained or used for query optimization. As data volume grows, the storage costs for MV can increase significantly. This aspect should be considered when designing a long-term strategy for MV. 
    
    \item \textbf{Usage cost:}\vspace{.3cm}
    
    Materialized views are great; however, there is a cost associated with the jobs that maintain them. We can calculate the cost using the following formula: \cite{10.1145/2206869.2206874}

    \input{Math/Total_cost}
  
\end{enumerate}




\subsection{ Static vs dynamic view selection } xxxx

\subsection{View matching for query optimization }

View matching is a critical process in query optimization that determines whether a query or sub-expression can be computed from existing materialized views. Since the objective of query optimization is to minimize the computational cost of query execution by taking advantage of precomputed results, this is an essential component.\vspace{.4cm}

 The view matching typically involves the following steps:
  \begin{itemize}
      \item \textbf{Query Decomposition:} The entering query is examined and deconstructed into its essential elements, including projection, selection, aggregation, and joins.
This step assists in determining the information requested by the query and the components accessible in materialized views.

      \item \textbf{Normalization and canonical form:} The incoming query and the materialized view definitions transform into a canonical form, facilitating a more straightforward comparison.
This normalization aids in removing discrepancies in the expression of similar operations, thereby enhancing the efficiency of matching.

     \item \textbf{Checking coverage:} The attributes and conditions of the query are assessed against those present in the materialized view to ascertain if the view encompasses all required data. This procedure guarantees that the materialized view encompasses all necessary data as specified by the query. In instances where the query includes a WHERE condition, it is essential that the materialized view contains an equivalent condition or one that is more restrictive.
     
      \item \textbf{Predicate Subsumption:} The predicates within the materialized view are evaluated to ascertain whether they subsume the predicates of the incoming query.
The selection conditions in the query must be either encompassed by or more stringent than those in the materialized view. If the predicates of the materialized view are more general, it remains applicable to the query by implementing further filtering as required.

      \item \textbf{Query Rewriting:} Should the materialized view be determined to encompass the incoming query, the query is subsequently reformulated to utilize the materialized view rather than visiting the basis tables.
This rewriting entails adjusting the original query to conform to the schema of the materialized view, sometimes incorporating supplementary filters or projections as necessary.

         \item \textbf{Cost Evaluation:} If several materialized views correspond to the query, the query optimizer assesses the cost of utilizing each available view and chooses the one with the lowest predicted cost.
This stage guarantees the selection of the most efficient execution plan, optimizing aspects such as I/O, memory use, and processing duration.

  \end{itemize}


\subsection{Conditions that must be fulfilled to be capable of using materialized views }

\subsection{ Materialized view management and selection approach}

\subsubsection{Materialized view management }


\begin{enumerate}[label=\alph*)]
    \item \textbf{Creation Strategies:}
    \item \textbf{Refresh Strategies:}
    \item \textbf{Storage management:}
    \item \textbf{consistency and  indexing :}
\end{enumerate}
\subsubsection{Materialized View Selection Approach}

  Query Frequency and Cost-Based Analysis:
  
\begin{enumerate}[label=\alph*)]
    \item \textbf{Query Patterns:}
    \item \textbf{Cost-Based Optimization}
    \item \textbf{Storage management:}
    \item \textbf{ Refresh Policies:}
\end{enumerate}

%% Three types of materialized views used to increase query performance and reduce the response time are as follows:

%%\begin{enumerate}[label=\alph*)]
   % \item \textbf{Materialized view management task}
    %\item \textbf{Materialized view selection}
    %\item \textbf{Incremental Materialized View Maintenance}
%%\end{enumerate}

\subsection{Multiple View Processing Plans (MVPP) }
\subsection{Do all required rows exist in the views }
\subsection{Particle Swarm Optimization ( PSO ) Algorithm
 }
\subsection{Maintenance of existing materialized views (refresh)
}
\subsection{Materialized View Selection using (PSO) algorithm }
\subsection{Do all required rows exist in the views }
\subsection{Fast filtering of MV}

\subsection{Database system Selection}
\subsection{Test Environment Setup }
\subsection{Query Design}
\subsection{Materialized View Creation} 
\subsection{Materialized View Management \& Selection Approach}
\subsection{View Maintenance Strategies}
\subsection{Testing Procedure}
\subsection{Tools and software}: 