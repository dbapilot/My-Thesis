%\chapter{Implementaion}
\section{Implementation}
This section describes a step-by-step process for effectively deploying materialized views, based on the earlier theoretical foundations, to reduce query execution time, minimize computational overhead, and enhance overall performance.

\subsection{Used Software and Tools}
\subsubsection{SQL Server Management Studio:}SQL Server Management Studio is actually an integrated environment that can maintain the SQL server infrastructure. It is used to manage the schema, tables, and materialized views of the database. In addition, it monitors the performance of the query using execution plans and statistics, and it helps to debug SQL queries and optimize their execution.

\subsubsection{Visual Studio Code:} Microsoft created this open-source integrated development environment (IDE) for web browsers, Linux, macOS, and Windows. It is used to write Python scripts for automation (e.g., measuring query performance), integrate MSSQL queries with Python using extensions, and debug Python and SQL scripts.

\subsubsection{Overleaf:} Overleaf is an open-source online, real-time collaborative LaTeX editor that simplifies the process of creating, editing, and collaborating on LaTeX documents.

\subsubsection{Microsoft SQL Server:} Microsoft SQL server is a relational database that provides a wide range of features for storing, processing, and securing data.


\subsubsection{Python:} Python is a high-level interpreted programming language known for its simplicity and readability. It was created by Guido van Rossum and released in 1991 \cite{martin2023stam,wijanarko2020prediksi} . It has become one of the most popular programming languages worldwide. The structure of the language and its object-oriented approach help programmers to write logical and clear code for small and large projects. Python libraries (packages) effectively simplify many important processes such as analysing and visualizing data, retrieving unstructured data from the web, image processing, building machine learning models, and textual information \cite{Samira_Gholizadeh2022}. Here, it has been used to implement the PSO algorithm to optimize query performance and execute and analyze the database programmatically.

\subsubsection{pyodbc:} Pyodbc is an open-source Python module that makes accessing ODBC databases simple. It implements the DB API 2.0 specification but is packed with even more Pythonic convenience.

\subsubsection{pandas:} The pandas constitute an open-source data manipulation and analysis tool that is fast, powerful, flexible, and easy to use. It is built entirely on the Python programming language. Pandas organizes and processes query performance data for further analysis. It is built entirely on the basis of the Python programming language. Panda Organizes and processes query performance data for further analysis.

\subsubsection{matplotlib:} Matplotlib is a comprehensive library for creating static, animated, and interactive visualizations in Python. Matplotlib makes easy things easy and hard things possible \cite{matplotlib}. It has been used to visualize performance improvements in different charts and tables. 
\subsubsection{Git:} Git is a version control system that is used for tracking the changes made in the files and for enabling a collaborative software world. Flexsibility, speed, and enablement of almost any applied workflow contribute to the great popularity of Git. It is more like a standard for version control - about 90 per cent of developers' primary system-in-use around the world fall into this category. This enables one to have version control over changes in Python and latex scripts and even multiple collaboration by users.
\subsection{Experimental Setup}
\subsection{Database System Selection}
%\subsection{Test Environment Setup }



 \begin{center}
     \textbf{.................Test Implementation ... Running ...........}
 \end{center}

\subsection{Practical Implementation}
\subsubsection{Test Environment Setup:}
\subsubsection{Identify Complex Queries} Analyzing the query workload to identify frequently used sub-queries, aggregation (Queries with GROUP BY, SUM, AVG)s, or frequently joins between tables. This is a very important part of identifying the frequent queries that need to be optimized. SQL server management studio can be used to analyze execution logs and identify the frequently executed and resource-intensive queries. For example, the following query to identify long-running queries:

\input{SQL/Query_identify}

\subsubsection{ Create Candidate Materialized Views (Indexed Views):} It is important to prepare the input data to get the best outcome. The following factors should be considered for the preparation. 

  \begin{itemize}
      \item \textbf{Create views}
      \item \textbf{Storage budget}
      \item \textbf{Query logs}
  \end{itemize}

  \input{SQL/Create_MSSQL}
  \input{SQL/Create_Views}
  
\subsubsection{Query Response Time:} Once materialized views are created, SQL queries are used to enable query statistics in SSMS:

   \input{SQL/Query_statistics}

\begin{itemize}
    \item \textbf{Queries without materialized views:}
    \item \textbf{Queries with materialized views:}
\end{itemize}

After running each query, note the elapsed time in the "Messages" tab in SSMS
   \input{Table/Response_time_comparion}

For example, the percentage difference for Query 1 is calculated as:
\[
\text{Difference (\%)} = \frac{\text{Without MV} - \text{With MV}}{\text{Without MV}} \times 100 = \frac{2.35 - 0.45}{2.35} \times 100 \approx 80.85\%
\]


\subsubsection{Automation with the PSO algorithm:}
 The following Python code illustrates the implementation of the PSO algorithm for multiple values. It evaluates various combinations of these parameters and selects the one that yields the best query response time.\vspace{.4cm}
 


\textbf{Code example to selecting the optimal view using PSO algorithm.}

  \input{Python/PSO_Best_Response}\vspace{.4cm}

\textbf{Example 2}
  \input{Python/PSO_python}\vspace{.4cm}

  \textbf{Output from PSO automation } 

  \input{Python/Python_output}
  \input{Python/python_output2}


 For each particle, the PSO algorithm evaluates the cost, updates personal and global best, and updates velocity and position. Finally, it prints the optimal combination of materialized views and the corresponding query response time.
 [0, 1, 0] means the second materialized view is selected for optimal query performance.
  


\subsubsection{Materialized View Management \& Selection Approach}
\subsubsection{View Maintenance and Refresh Strategies:} Manual or automatic refresh strategies can be set up according to the requirements query to create a scheduled job:

\input{SQL/Refresh_config}

\subsubsection{Performance Testing and Data Analysis}


 \input{Table/Response_time_comparion}

% Test Test Test Test---------------------------------Test 
\begin{tikzpicture}
    \begin{axis}[
        width=12cm, height=8cm,
        ybar=0.5pt, % Bar style
        bar width=15pt,
        symbolic x coords={Query 1, Query 2, Query 3},
        xtick=data,
        ymin=0, ymax=5,
        ylabel={Execution Time (seconds)},
        xlabel={Queries},
        legend style={at={(0.5,-0.2)}, anchor=north, legend columns=-1},
        nodes near coords, % Show data labels
        enlarge x limits=0.25
    ]
        % Without Materialized View Data
        \addplot coordinates {(Query 1,2.35) (Query 2,3.78) (Query 3,4.21)};
        % With Materialized View Data
        \addplot coordinates {(Query 1,0.45) (Query 2,0.62) (Query 3,0.87)};
        
        \legend{Without Materialized View, With Materialized View}
    \end{axis}
\end{tikzpicture}

\begin{table}[h!]
    \centering
    \begin{tabular}{@{}lccc@{}}
        \toprule
        \textbf{Query} & \textbf{Without MV (s)} & \textbf{With MV (s)} & \textbf{Difference (\%)} \\ \midrule
        Query 1        & 2.35                   & 0.45                 & 80.85                   \\
        Query 2        & 3.78                   & 0.62                 & 83.61                   \\
        Query 3        & 4.21                   & 0.87                 & 79.34                   \\ \bottomrule
    \end{tabular}
    \caption{Execution Time Difference Between Queries With and Without Materialized Views}
    \label{tab:performance}
\end{table}


\begin{table}[h!]
    \centering
    \begin{tabular}{@{}lccc@{}}
        \toprule
        \textbf{Query} & \textbf{Without MV (s)} & \textbf{With MV (s)} & \textbf{Difference (\%)} \\ \midrule
        Query 1        & 2.35                   & 0.45                 & 80.85                   \\
        Query 2        & 3.78                   & 0.62                 & 83.61                   \\
        Query 3        & 4.21                   & 0.87                 & 79.34                   \\ \bottomrule
    \end{tabular}
    \caption{Performance Comparison for Queries With and Without Materialized Views}
    \label{tab:performance}
\end{table}

For example, the percentage difference for Query 1 is calculated as:
\[
\text{Difference (\%)} = \frac{\text{Without MV} - \text{With MV}}{\text{Without MV}} \times 100 = \frac{2.35 - 0.45}{2.35} \times 100 \approx 80.85\%
\]